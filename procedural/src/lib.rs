use proc_macro::TokenStream;

mod apis;
mod construct_runtime;
mod models;
mod runtime_apis;

/// Construct runtime macro wrapper
/// This macro allows to construct runtime operating with abstractions as long as with pallets. 
/// It allows you omit the pallet indexes -- they will be assigned in ascending order. 
/// This API may change in future releases, it is not yet stabilised.
/// 
/// Example:
/// ```
/// #[openzeppelin_construct_runtime]
/// mod runtime {
///     #[abstraction]
///     struct System; // Available names are System, Consensus, XCM, Assets, Governance, EVM.
///     #[pallet]
///     type Pallet = pallet_crate; // It mimics the second version of construct runtime macro, but without the pallet_index assignment
/// }
/// ```
/// 
/// Supported abstractions and pallets inside them:
/// * `System`: 
///     * `frame_system`
///     * `pallet_timestamp`
///     * `parachain_info`
///     * `pallet_scheduler`
///     * `pallet_preimage`
///     * `pallet_proxy`
///     * `pallet_balances`
///     * `pallet_utility`
///     * `cumulus_pallet_parachain_system`
///     * `pallet_multisig`
///     * `pallet_session`
/// * `Assets`
///     * `pallet_assets`
///     * `pallet_transaction_payment`
///     * `pallet_asset_manager`
/// * `Consensus`
///     * `pallet_authorship`
///     * `pallet_aura`
///     * `cumulus_pallet_aura_ext`
///     * `pallet_collator_selection`
///     * `pallet_session
/// * `Governance`
///     * `pallet_sudo`
///     * `pallet_treasury`
///     * `pallet_conviction_voting`
///     * `pallet_whitelist`
///     * `pallet_custom_origins`
///     * `pallet_referenda`
/// * `XCM` 
///     * `pallet_message_queue`
///     * `cumulus_pallet_xcmp_queue`
///     * `pallet_xcm`
///     * `cumulus_pallet_xcm`
///     * `pallet_xcm_weight_trader`
///     * `orml_xtokens`
///     * `pallet_xcm_transactor`
/// * `EVM` 
///     * `pallet_ethereum`
///     * `pallet_evm`
///     * `pallet_base_fee`
///     * `pallet_evm_chain_id`
#[proc_macro_attribute]
pub fn openzeppelin_construct_runtime(_: TokenStream, tokens: TokenStream) -> TokenStream {
    construct_runtime::construct_openzeppelin_runtime(tokens)
}

/// Runtime API macro wrapper
/// This macro wraps the `impl_runtime_api` macro and provides our implementations of them.
/// It also works in the same groupings as our abstractions pallets and to get the runtime API implementations you only need to provide some types.
/// 
/// Example:
/// ```
/// #[openzeppelin_runtime_apis]
/// mod apis {
///     // these types should be present and required for all abstractions
///     // runtime generated by construct_runtime
///     type Runtime = Runtime;
///     // block type 
///     type Block = Block;
/// 
///     #[abstraction]
///     mod assets {
///         type TransactionPayment = TransactionPayment;
///         type RuntimeCall = RuntimeCall;
///         type Balance = Balance;
///     }
/// 
///     // Any impl block can also go there, it will be ported to the `impl_runtime_api!`
/// }
/// ```
/// 
/// Supported abstractions:
/// * `EVM`
///   * Implemented APIs:
///     * `fp_rpc::EthereumRuntimeRPCApi`
///     * `fp_rpc::ConvertTransactionRuntimeApi`
///   * Required Types:
///     * `RuntimeCall` -- runtime call generated by `construct_runtime` macro
///     * `Executive` -- `frame_executive::Executive` specification used by parachain system
///     * `Ethereum` -- `pallet_ethereum` pallet struct generated by `construct_runtime` macro
/// * `assets`
///   * Implemented APIs:
///     * `pallet_transaction_payment_rpc_runtime_api::TransactionPaymentApi`
///     * `pallet_transaction_payment_rpc_runtime_api::TransactionPaymentCallApi`
///   * Required Types:
///     * `TransactionPayment` -- `pallet_transaction_payment` struct pallet generated by `construct_runtime` macro
///     * `RuntimeCall` -- runtime call generated by `construct_runtime` macro
///     * `Balance` -- type used for balance specification (e.g. in `pallet_balances` config)
/// * `consensus`
///   * Implemented APIs:
///     * `sp_consensus_aura::AuraApi`
///     * `sp_session::SessionKeys`
///     * `cumulus_primitives_aura::AuraUnincludedSegmentApi` (if `async-backing` feature is enabled)
///   * Required Types:
///     * `SessionKeys` -- struct generated by `impl_opaque_keys` macro 
///     * `Aura` -- `pallet_aura` struct pallet generated by `construct_runtime` macro (only if `async-backing` feature is not enabled)
///     * `SlotDuration` -- constant that is use for slot duration definition (only if `async-backing` feature is enabled)
///     * `ConsensusHook` -- type that is used in `cumulus_pallet_parachain_system::Config::ConsensusHook` (only if `async-backing` feature is enabled)
/// * `system`
///   * Implemented APIs:
///     * `sp_api::Core`
///     * `sp_api::Metadata`
///     * `sp_block_builder::BlockBuilder`
///     * `sp_transaction_pool::runtime_api::TaggedTransactionQueue`
///     * `sp_offchain::OffchainWorkerApi`
///     * `frame_system_rpc_runtime_api::AccountNonceApi`
///     * `cumulus_primitives_core::CollectCollationInfo`
///     * `frame_try_runtime::TryRuntime` (under a `try-runtime` feature)
///     * `sp_genesis_builder::GenesisBuilder`
///   * Required Types:
///     * `Executive` -- `frame_executive::Executive` specification used by parachain system
///     * `System` -- `frame_system` pallet struct generated by `construct_runtime` macro
///     * `ParachainSystem` -- `cumulus_pallet_parachain_system` pallet struct generated by `construct_runtime` macro
///     * `RuntimeVersion` -- runtime version, generated by `sp_version::runtime_version`
///     * `AccountId` -- account id type that was specified in `frame_system::Config`
///     * `Nonce` -- nonce type that was specified in `frame_system::Config`
///     * `RuntimeGenesisConfig` -- type generated by `construct_runtime` macro.
///     * `RuntimeBlockWeights` -- type implementing `Get<BlockWeights>`, often built by `BlockWeights::builder`
/// * `benchmarks`
///   * Implemented APIs:
///     * `frame_benchmarking::Benchmark` (under `runtime-benchmarks` feature)
///   * Required Types:
///     * `Assets` -- `palet_assets` pallet struct generated by `construct_runtime` macro
///     * `AssetManager` -- `pallet_asset_manager` pallet struct generated by `construct_runtime` macro
///     * `AssetType` -- struct that describes foreign assets in XCM configuration (e.g. the one that was passed to `AssetType` field in `AssetsConfig`)
///     * `RuntimeOrigin` -- type generated by `construct_runtime` macro
///     * `RelayLocation` -- `Location` type pointing to the relaychain
///     * `System` -- `frame_system` pallet struct generated by `construct_runtime` macro
///     * `ParachainSystem` -- `cumulus_pallet_parachain_system` pallet struct generated by `construct_runtime` macro
///     * `ExistentialDeposit` -- type that describes existential deposit (e.g. the one passed to `SystemConfig`)
///     * `AssetId` -- type that describes internal asset id (e.g `AssetId` passet to `AssetsConfig`)
///     * `XCMConfig` -- struct that implements `xcm_executor::Config`. If you are using pallet abstractions it is generated by XCM abstraction and called `XcmExecutorConfig`
///     * `AccountId` -- account id type that was specified in `frame_system::Config`
///     * `Cents` -- constant that represents 1/100 of your native token.
///     * `FeeAssetId` -- type that describes an asset to pay XCM fees in. If you used an abstraction macro for XCM support, it was generated along the way and named `FeeAssetId`.
///     * `TransactionByteFee` -- type that describes fee per byte of data. If you used an abstraction macro for assets support it was generated with the same name.
///     * `Address` -- type that describes address format for describing accounts.
///     * `Balances` -- `pallet_balances` pallet struct generated by `construct_runtime` macro
#[proc_macro_attribute]
pub fn openzeppelin_runtime_apis(_: TokenStream, input: TokenStream) -> TokenStream {
    runtime_apis::impl_openzeppelin_runtime_apis(input)
}
