# Openzeppelin Pallet Abstractions Procedural Macros

## `construct_runtime!`

We have made an abstraction over the `construct_runtime!`. The macro itself has changed, supporting both abstractions and regular pallets:

```rust
#[openzeppelin_construct_runtime]
mod runtime {
    struct System; // Available names are System, Consensus, XCM, Assets, Governance, EVM.
    #[pallet]
    type Pallet = pallet_crate; // It mimics the second version of construct runtime macro, but without the pallet_index assignment
}
```

Pallet index assignment is hidden from this API. If you want to use it, please create an issue.

#### Supported abstractions:

* `System` -- `frame_system`, `pallet_timestamp`, `parachain_info`, `pallet_scheduler`, `pallet_preimage`, `pallet_proxy`, `pallet_balances`, `pallet_utility`, `cumulus_pallet_parachain_system`, `pallet_multisig`, `pallet_session`
* `Assets` -- `pallet_assets`, `pallet_transaction_payment`, `pallet_asset_manager`
* `Consensus` -- `pallet_authorship`, `pallet_aura`, `cumulus_pallet_aura_ext`, `pallet_collator_selection`
* `Governance` -- `pallet_sudo`, `pallet_treasury`, `pallet_conviction_voting`, `pallet_whitelist`, `pallet_custom_origins`, `pallet_referenda`
* `XCM` -- `pallet_message_queue`, `cumulus_pallet_xcmp_queue`, `pallet_xcm`, `cumulus_pallet_xcm`, `pallet_xcm_transactor`, `orml_xtokens`, `pallet_xcm_weight_trader`
* `EVM` -- `pallet_ethereum`, `pallet_evm`, `pallet_base_fee`, `pallet_evm_chain_id`, `pallet_erc20_xcm_bridge`

### `impl_runtime_apis!`

We have also made an abstraction for `impl_runtime_apis!` macro. There is now a new macro where you only provide the types and structs:

```rust
#[openzeppelin_runtime_apis]
mod apis {
    // these types should be present and required for all abstractions
    // runtime generated by construct_runtime
    type Runtime = Runtime;
    // block type 
    type Block = Block;

    #[abstraction]
    mod assets {
        type TransactionPayment = TransactionPayment;
        type RuntimeCall = RuntimeCall;
        type Balance = Balance;
    }

    // Any impl block can also go there
}
```

Supported abstractions:

| Abstraction name | Implemented APIs | Required configs |
|---|---|---|
| `EVM` | * `fp_rpc::EthereumRuntimeRPCApi`<br>* `fp_rpc::ConvertTransactionRuntimeApi`  | * `RuntimeCall` -- runtime call generated by `construct_runtime` macro<br>* `Executive` -- `frame_executive::Executive` specification used by parachain system<br>* `Ethereum` -- `pallet_ethereum` pallet struct generated by `construct_runtime` macro |
| `assets` | * `pallet_transaction_payment_rpc_runtime_api::TransactionPaymentApi`<br>* `pallet_transaction_payment_rpc_runtime_api::TransactionPaymentCallApi` | * `TransactionPayment` -- `pallet_transaction_payment` struct pallet generated by `construct_runtime` macro<br> * `RuntimeCall` -- runtime call generated by `construct_runtime` macro<br> * `Balance` -- type used for balance specification (e.g. in `pallet_balances` config) |
| `consensus` | * `sp_consensus_aura::AuraApi`<br> * `sp_session::SessionKeys`<br> * `cumulus_primitives_aura::AuraUnincludedSegmentApi` (if `async-backing` feature is enabled) | * `SessionKeys` -- struct generated by `impl_opaque_keys` macro <br> * `Aura` -- `pallet_aura` struct pallet generated by `construct_runtime` macro (only if `async-backing` feature is not enabled)<br> * `SlotDuration` -- constant that is use for slot duration definition (only if `async-backing` feature is enabled)<br> * `ConsensusHook` -- type that is used in `cumulus_pallet_parachain_system::Config::ConsensusHook` (only if `async-backing` feature is enabled) |
| `system` |  * `sp_api::Core`<br> * `sp_api::Metadata`<br> * `sp_block_builder::BlockBuilder`<br> * `sp_transaction_pool::runtime_api::TaggedTransactionQueue` <br> * `sp_offchain::OffchainWorkerApi` <br> * `frame_system_rpc_runtime_api::AccountNonceApi` <br> * `cumulus_primitives_core::CollectCollationInfo` <br> * `frame_try_runtime::TryRuntime` (under a `try-runtime` feature) <br> * `sp_genesis_builder::GenesisBuilder` | * `Executive` -- `frame_executive::Executive` specification used by parachain system<br> * `System` -- `frame_system` pallet struct generated by `construct_runtime` macro<br> * `ParachainSystem` -- `cumulus_pallet_parachain_system` pallet struct generated by `construct_runtime` macro<br> * `RuntimeVersion` -- runtime version, generated by `sp_version::runtime_version`<br> * `AccountId` -- account id type that was specified in `frame_system::Config`<br> * `Nonce` -- nonce type that was specified in `frame_system::Config`<br> * `RuntimeGenesisConfig` -- type generated by `construct_runtime` macro.<br> * `RuntimeBlockWeights` -- type implementing `Get<BlockWeights>`, often built by `BlockWeights::builder`  |
| `benchmarks` |  * `frame_benchmarking::Benchmark` (under `runtime-benchmarks` feature) | * `Assets` -- `palet_assets` pallet struct generated by `construct_runtime` macro<br> * `AssetManager` -- `pallet_asset_manager` pallet struct generated by `construct_runtime` macro<br> * `AssetType` -- struct that describes foreign assets in XCM configuration (e.g. the one that was passed to `AssetType` field in `AssetsConfig`)<br> * `RuntimeOrigin` -- type generated by `construct_runtime` macro<br> * `RelayLocation` -- `Location` type pointing to the relaychain.<br> * `System` -- `frame_system` pallet struct generated by `construct_runtime` macro<br> * `ParachainSystem` -- `cumulus_pallet_parachain_system` pallet struct generated by `construct_runtime` macro<br> * `ExistentialDeposit` -- type that describes existential deposit (e.g. the one passed to `SystemConfig`)<br> * `AssetId` -- type that describes internal asset id (e.g `AssetId` passet to `AssetsConfig`)<br>  * `XCMConfig` -- struct that implements `xcm_executor::Config`. If you are using pallet abstractions it is generated by XCM abstraction and called `XcmExecutorConfig`<br> * `AccountId` -- account id type that was specified in `frame_system::Config`<br> * `Cents` -- constant that represents 1/100 of your native token.<br> * `FeeAssetId` -- type that describes an asset to pay XCM fees in. If you used an abstraction macro for XCM support, it was generated along the way and named `FeeAssetId`. <br> * `TransactionByteFee` -- type that describes fee per byte of data. If you used an abstraction macro for assets support it was generated with the same name.<br> * `Address` -- type that describes address format for describing accounts.</br> * `Balances` -- `pallet_balances` pallet struct generated by `construct_runtime` macro |